fmod PROCESS is
    including NAT .

    sort Process .

    op process : Nat State -> Process [ctor] .

    sort State .
    op idle : -> State .
    op acquire-pc : Nat -> State .
    op critical : -> State .
    op release-pc : Nat -> State .
endfm


fmod REGISTER is
    including NAT .

    sort Register .

    op register : Nat -> Register [ctor] .
endfm


mod FISCHER is
    including PROCESS .
    including REGISTER .

    including CONFIGURATION .

    subsort Process < Configuration .
    subsort Register < Configuration .

    vars N I : Nat .
    vars S T : State .

    rl [acquire_mutex] :
        process(I, idle)
      =>
        process(I, acquire-pc(1)) .

    rl [read-register] :
        process(I, acquire-pc(1)) register(N)
      =>
      if N == 0 then
          process(I, acquire-pc(2)) register(N)
        else
          process(I, acquire-pc(1)) register(N)
        fi .                    *** in time DELTA

    rl [write-register] :
        process(I, acquire-pc(2)) register(N)
      =>
        process(I, acquire-pc(3)) register(I) . *** in time DELTA

    rl [delay-delta] :
        process(I, acquire-pc(3))
      =>
        process(I, acquire-pc(4)) . *** in time DELTA .

    rl [read-register2] :
        process(I, acquire-pc(4)) register(N) =>
      if N == I then
          process(I, critical) register(N)
        else
          process(I, acquire-pc(1)) register(N)
        fi .                    *** in time DELTA

    rl [release_mutex] :
        process(I, critical)
      =>
        process(I, release-pc(1)) .

    rl [write-register2] :
        process(I, release-pc(1)) register(I)
      =>
        process(I, idle) register(0) .

endm    


mod TESTS is
    including FISCHER .

    op c1 : -> Configuration .
    op c2 : -> Configuration .
    
    eq c1 = process(1, idle) register(0) .
    eq c2 = process(1, idle) process(2, idle) register(0) .

endm

search [1] c2 =>* C:Configuration process(1, critical) process(2, critical) .


q